
-	Задача разделена на 4 блока:
	checker, informer, mailer, runner.

	
-	сhecker - проверяет валидность email и заполняет поля
	`emails`.checked и `emails`.valid.


-	informer - отслеживает необходимость отправки писем
	и сохраняет их в таблицу `mails`.
	Если в текущей транзакции возникла ошибка,
	то будут отменены и сформированные письма.
	Это устранит дублирование писем при возобнавлении 
	работы.
	Также модуль фиксирует факт и время создания письма в
	таблице `email_informed`. Это позволяет делать 
	мораторий на повторную отправку писем на указанный срок.


-	mailer - отсылает письма из таблицы `mails` и удаляет
	их из таблицы.
	
	
-	runner - запускаемый из cron скрипт, который, 
		в соответствии с переданным ему параметром,
		запускает модули checker, informer или mailer.
		
		Этот модуль просматривает список текущих процессов,
		подсчитывает кол-во процессов каждого типа
		(checker, informer, mailer) и, или запускает
		очередной	процесс, или завершает работу.
		
		Таким образом все модули являются многопоточными,
		на одновременное выполнение может быть запущено
		большее или меньшее кол-во процессов (в зависимости
		от ситуации).
		
		
-	Т.к. в Тех.задании не была указана версия mysql,
	то в текущей версии использовалась 8.0.21,
	а межпроцессорное взаимодествие на технологии
	FOR UPDATE SKIP LOCKED.
	
	Если это не приемлемо, то можно немного изменить
	данную конфигурацию в которой просмотр таблицы
	будет происходить в одном потоке (или в нескольких,
	но жестко разбитых на непересекающиеся диапахоны - 
	sharding), долгие операции будут запускаться в 
	отдельных процессах, а передача данных в них
	будет производиться через файл, имя которого
	будет передано параметром запускаемому процессу.
	
	Ещё более простой, но наимее гибкий вариант
	это просто запуск процессов с передачей им жетских
	диапазонов (например, первые 6 букв емайла).


-	Обработка ошибок реализована через глобольный блок
	try catch в модуле runner.php и сводится к идее:
	в любой непонятной ситуации выбрасывать Exception,
	который бцдет залоггирован в блоке catch,
	а текущей транзакции будет сделан rollback.
	
	
-	Работа с базой, в соответствии с Тех.заданием,
	реализована без ООП и происходит через промежуточные
	функции, что приводит к 2-м удобным следствиям:
	
	- функция работы с запросами используется синтаксис
		mysqli_stmt_prepere(), но при этом сама 
		mysqli_stmt_prepere() не используется.
		Т.е. запрос и параметры четко разделены, 
		при этом параметры автоматически экранируются.
		
	- сама строка запроса, например:
	
		SELECT u.email, u.username 
		FROM users u, emails e, email_informed ei
		WHERE u.email_confirmed = 1 
					AND u.validts < unix_timestamp() - ? 
					AND ei.email = e.email 
					AND ( ei.datets IS NULL 
								OR ei.datets < unix_timestamp() - ? )
					AND e.valid = 1
					AND e.email = u.email
					LIMIT ?
					FOR UPDATE SKIP LOCKED
		
	в которой вместо значений используются значки "?",
	может служить ключем для сбора статистики по 
	выполнению этого запроса (с любыми параметрами).
	- время выполнения самого запроса
	- кол-во выполнений запроса в текущем скрипте и общее
	- процент от времени выполнения текущего скрипта
	- цепочка вызовов скриптов, которая привела к запросу
	и т.п.
	
	Эта возможность позволяет буквально "как рентгеном"
	просвечивать весь сайт и видеть когда, в каких модулях
	и при каких условиях тормозит тот или иной запрос.
	

- Для ускорения sql-запросов на базе полей, описанных
	в Тех.задании, созданы индексы, а сами запросы
	составлены так, чтобы эти индексы использовались.
	Под запросами приложены таблицы explain.
